#!/usr/bin/env python3
"""
Script writer - generates Python scripts from natural language descriptions.

Takes a natural language request and generates a working Python script with:
- Proper imports and error handling
- Command-line arguments where appropriate
- Logging to atlas/logs/
- Integration with existing atlas patterns (Telegram, .env, etc.)

Usage:
    python script_writer.py --task "description" --output "path/to/script.py" [--schedule "cron"]
"""

import argparse
import json
import os
import sys
from pathlib import Path

REPO_ROOT = Path(__file__).resolve().parent.parent.parent


def generate_script(task_description: str, output_path: Path, schedule: str = None) -> dict:
    """
    Generate a Python script from natural language description.

    Args:
        task_description: Natural language description of what the script should do
        output_path: Where to save the script (relative to repo root)
        schedule: Optional cron schedule if this should run automatically

    Returns:
        Dict with success status, script path, and optional cron info
    """
    # This is a placeholder implementation. In production, you'd use:
    # 1. Claude API with a code generation prompt
    # 2. Template-based generation for common patterns
    # 3. Hybrid approach: templates + LLM for custom logic

    # For now, let's create a basic template-based system
    script_type = _classify_task(task_description)

    if script_type == "telegram_notifier":
        script_content = _generate_telegram_notifier(task_description)
    elif script_type == "web_scraper":
        script_content = _generate_web_scraper(task_description)
    elif script_type == "file_processor":
        script_content = _generate_file_processor(task_description)
    elif script_type == "api_poller":
        script_content = _generate_api_poller(task_description)
    else:
        script_content = _generate_generic_script(task_description)

    # Ensure output directory exists
    full_path = REPO_ROOT / output_path
    full_path.parent.mkdir(parents=True, exist_ok=True)

    # Write script
    full_path.write_text(script_content, encoding="utf-8")
    full_path.chmod(0o755)

    result = {
        "success": True,
        "script_path": str(output_path),
        "full_path": str(full_path),
        "message": f"Created script: {output_path}"
    }

    # If schedule provided, suggest adding to cron
    if schedule:
        python_bin = sys.executable
        log_file = REPO_ROOT / "logs" / f"{full_path.stem}.log"
        cron_command = f"{python_bin} {full_path} >> {log_file} 2>&1"
        result["cron_suggestion"] = {
            "schedule": schedule,
            "command": cron_command,
            "add_with": f"python tools/system/cron_manager.py add '{schedule}' '{cron_command}'"
        }

    return result


def _classify_task(description: str) -> str:
    """Classify task type from description."""
    desc_lower = description.lower()

    if any(word in desc_lower for word in ["telegram", "notify", "send message", "alert"]):
        return "telegram_notifier"
    elif any(word in desc_lower for word in ["scrape", "fetch", "download", "web page"]):
        return "web_scraper"
    elif any(word in desc_lower for word in ["process file", "read file", "parse", "csv", "json"]):
        return "file_processor"
    elif any(word in desc_lower for word in ["poll", "check api", "monitor", "watch"]):
        return "api_poller"
    else:
        return "generic"


def _generate_telegram_notifier(description: str) -> str:
    """Generate a script that sends Telegram notifications."""
    return '''#!/usr/bin/env python3
"""
{description}

Generated by script_writer.py
"""

import json
import os
import sys
import urllib.request
from datetime import datetime
from pathlib import Path
from zoneinfo import ZoneInfo

TZ = ZoneInfo("America/Los_Angeles")


def send_telegram(text: str, chat_id: str = None) -> bool:
    """Send Telegram message."""
    token = os.environ.get("TELEGRAM_BOT_TOKEN", "")
    if not token or token.startswith("<"):
        print("ERROR: TELEGRAM_BOT_TOKEN not set", file=sys.stderr)
        return False

    if not chat_id:
        chat_id = os.environ.get("TELEGRAM_CHAT_ID", "8241581699")

    url = f"https://api.telegram.org/bot{{token}}/sendMessage"
    payload = json.dumps({{
        "chat_id": chat_id,
        "text": text,
        "parse_mode": "Markdown"
    }}).encode()

    try:
        req = urllib.request.Request(url, data=payload, headers={{"Content-Type": "application/json"}})
        with urllib.request.urlopen(req, timeout=10) as resp:
            return resp.status == 200
    except Exception as e:
        print(f"ERROR: Failed to send Telegram: {{e}}", file=sys.stderr)
        return False


def main():
    # TODO: Implement your logic here
    # This is a template - customize based on: {description}

    message = f"Test notification at {{datetime.now(TZ).strftime('%Y-%m-%d %H:%M')}}"

    if send_telegram(message):
        print("Notification sent successfully")
    else:
        print("Failed to send notification", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
'''.format(description=description)


def _generate_web_scraper(description: str) -> str:
    """Generate a web scraping script."""
    return '''#!/usr/bin/env python3
"""
{description}

Generated by script_writer.py
"""

import json
import sys
import urllib.request
from pathlib import Path

REPO_ROOT = Path(__file__).resolve().parent.parent.parent


def fetch_page(url: str) -> str:
    """Fetch a web page."""
    try:
        req = urllib.request.Request(url, headers={{"User-Agent": "Mozilla/5.0"}})
        with urllib.request.urlopen(req, timeout=15) as resp:
            return resp.read().decode("utf-8")
    except Exception as e:
        print(f"ERROR: Failed to fetch {{url}}: {{e}}", file=sys.stderr)
        return None


def main():
    # TODO: Implement your scraping logic here
    # This is a template - customize based on: {description}

    url = "https://example.com"  # Replace with actual URL
    content = fetch_page(url)

    if not content:
        print("Failed to fetch page", file=sys.stderr)
        sys.exit(1)

    # Parse content here
    # Example: extract data, save to file, send notification, etc.

    print("Scraping completed successfully")


if __name__ == "__main__":
    main()
'''.format(description=description)


def _generate_file_processor(description: str) -> str:
    """Generate a file processing script."""
    return '''#!/usr/bin/env python3
"""
{description}

Generated by script_writer.py
"""

import argparse
import sys
from pathlib import Path


def process_file(file_path: Path):
    """Process a single file."""
    if not file_path.exists():
        print(f"ERROR: File not found: {{file_path}}", file=sys.stderr)
        return False

    try:
        content = file_path.read_text(encoding="utf-8")
        # TODO: Add your processing logic here
        # This is a template - customize based on: {description}

        print(f"Processed {{file_path}}")
        return True
    except Exception as e:
        print(f"ERROR: Failed to process {{file_path}}: {{e}}", file=sys.stderr)
        return False


def main():
    parser = argparse.ArgumentParser(description="{description}")
    parser.add_argument("file", help="File to process")
    args = parser.parse_args()

    file_path = Path(args.file)
    if process_file(file_path):
        print("Processing completed successfully")
    else:
        sys.exit(1)


if __name__ == "__main__":
    main()
'''.format(description=description)


def _generate_api_poller(description: str) -> str:
    """Generate an API polling script."""
    return '''#!/usr/bin/env python3
"""
{description}

Generated by script_writer.py
"""

import json
import os
import sys
import urllib.request
from datetime import datetime
from pathlib import Path
from zoneinfo import ZoneInfo

REPO_ROOT = Path(__file__).resolve().parent.parent.parent
STATE_FILE = REPO_ROOT / "data" / "api_poller_state.json"
TZ = ZoneInfo("America/Los_Angeles")


def load_state() -> dict:
    """Load last state from disk."""
    if not STATE_FILE.exists():
        return {{}}
    try:
        return json.loads(STATE_FILE.read_text(encoding="utf-8"))
    except (json.JSONDecodeError, OSError):
        return {{}}


def save_state(state: dict):
    """Save state to disk."""
    try:
        STATE_FILE.parent.mkdir(parents=True, exist_ok=True)
        STATE_FILE.write_text(json.dumps(state, indent=2), encoding="utf-8")
    except OSError as e:
        print(f"ERROR: Failed to save state: {{e}}", file=sys.stderr)


def check_api() -> dict:
    """Check the API for updates."""
    # TODO: Implement your API check here
    # This is a template - customize based on: {description}

    url = "https://api.example.com/endpoint"  # Replace with actual API
    try:
        req = urllib.request.Request(url, headers={{"User-Agent": "Mozilla/5.0"}})
        with urllib.request.urlopen(req, timeout=10) as resp:
            data = json.loads(resp.read().decode("utf-8"))
            return data
    except Exception as e:
        print(f"ERROR: API check failed: {{e}}", file=sys.stderr)
        return None


def main():
    state = load_state()
    data = check_api()

    if not data:
        print("WARNING: Could not fetch API data")
        sys.exit(1)

    # TODO: Compare with previous state and take action if changed
    # This is a template - customize based on: {description}

    # Save updated state
    state["last_check"] = datetime.now(TZ).isoformat()
    state["last_data"] = data
    save_state(state)

    print("API check completed")


if __name__ == "__main__":
    main()
'''.format(description=description)


def _generate_generic_script(description: str) -> str:
    """Generate a generic Python script."""
    return '''#!/usr/bin/env python3
"""
{description}

Generated by script_writer.py
"""

import sys
from pathlib import Path

REPO_ROOT = Path(__file__).resolve().parent.parent.parent


def main():
    """Main entry point."""
    # TODO: Implement your logic here
    # Task: {description}

    print("Script executed successfully")


if __name__ == "__main__":
    main()
'''.format(description=description)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Generate Python scripts from natural language")
    parser.add_argument("--task", required=True, help="Natural language description of what the script should do")
    parser.add_argument("--output", required=True, help="Output path relative to repo root (e.g., 'tools/custom/my_script.py')")
    parser.add_argument("--schedule", help="Optional cron schedule (e.g., '0 17 * * *' for 5pm daily)")

    args = parser.parse_args()

    result = generate_script(args.task, Path(args.output), args.schedule)
    print(json.dumps(result, indent=2))
    sys.exit(0 if result.get("success") else 1)
